非常棒的问题！🌟
这个问题其实非常“工程”，因为在真实相机画面里，**灯条检测+装甲匹配**最容易出错的地方，就是各种边界（非理想）情况。
我给你列出最全的一份「边界情况大全」——每一种都说明成因、表现、会影响哪些指标，以及如何补救或预处理。
这些是 RM 视觉 / OpenCV 检测模块里非常核心的经验。

---

## 🧩 一、几何层面常见边界情况（最典型）

### 1️⃣ **一侧灯条被遮挡 / 部分识别**

**原因**：

* 敌方机器人被掩体或障碍挡住；
* 灯条太亮导致饱和，轮廓断裂；
* 灯条被分割成两块，只识别出一部分。

**表现**：

* `side_ratio` → 很大（>2）；
* 灯条角度可能正常，但 `ratio` 变小（因为一边短）；
* 四点形状不再接近矩形。

**对策**：

* 计算 `side_ratio` 判断对称性；
* 允许“伪装甲”暂时通过（用于跟踪滤波补偿）；
* 用时间上的一致性（tracking）过滤单帧误检。

---

### 2️⃣ **灯条角度相差过大**

**原因**：

* 透视角太大（俯视/仰视）；
* 一侧灯条识别角度错误；
* 图像噪声、曝光问题。

**表现**：

* `abs(left.angle - right.angle)` > 10°；
* `rectangular_error` 明显偏大；
* 四点拟合出的矩形呈梯形或平行四边形。

**对策**：

* 限制平行度误差阈值；
* 使用 `cv::fitLine()` 对两灯条的点云重新计算方向；
* 对透视情况下放宽垂直条件、改用“平行性优先”策略。

---

### 3️⃣ **两灯条中心距离异常**

**原因**：

* 错误匹配了非配对灯条；
* 近距离时灯条看起来分得太开；
* 远距离时合并成一条。

**表现**：

* `ratio = width / max_length` 过大或过小；
* “装甲”过宽（>实际比例）或几乎没宽度。

**对策**：

* 依据实际物理尺寸限定 `ratio` 范围；

  * 小装甲常在 `[1.5, 3.2]`；
  * 大装甲常在 `[3.5, 5.0]`；
* 若检测出多个候选，选取 `ratio` 最近于经验值的。

---

### 4️⃣ **灯条顺序错误（左右反）**

**原因**：

* 灯条检测后未排序；
* 检测到的轮廓顺序随机；
* 矩阵坐标中，Y轴向下导致视觉混乱。

**表现**：

* 装甲被“反着”拼接；
* 中心点正常，但角点顺序混乱；
* `roll` 的符号不一致。

**对策**：

* 构造前强制按 `x` 坐标排序：

  ```cpp
  if (left.center.x > right.center.x)
      std::swap(left, right);
  ```
* 保证 `points` 顺序为一致的顺时针 / 逆时针。

---

### 5️⃣ **灯条太短或太宽**

**原因**：

* 阈值分割过度；
* 模糊、曝光导致矩形近似正方形。

**表现**：

* 灯条 `length / width < 2`；
* `ratio` 被放大（看起来像“胖装甲”）。

**对策**：

* 单独对 `Lightbar` 内部结构过滤；

  * 例如 `if (ratio < 2.0 || ratio > 15.0) reject;`
* 在匹配阶段也过滤掉这样的灯条。

---

### 6️⃣ **灯条方向相反（180°翻转）**

**原因**：

* 旋转矩形角度 `RotatedRect::angle` 定义模糊；
* 不同 OpenCV 版本的角度取值范围不同（有的为 -90°~0°，有的为 0°~180°）。

**表现**：

* 一侧角度差 π（180°）；
* 明明平行，却计算出角度差很大。

**对策**：

* 用标准化角度函数：

  ```cpp
  auto normalize_angle = [](float a) {
      while (a < 0) a += CV_PI;
      while (a > CV_PI) a -= CV_PI;
      return a;
  };
  ```
* 统一所有角度到 `[0, π)` 范围；
* 比较角度差时用 `min(diff, π - diff)`。

---

## 🎥 二、图像层面常见边界情况

### 7️⃣ **亮度过曝 / 反光**

**原因**：

* LED灯条在曝光下过饱和，轮廓膨胀；
* 有反光物体（如金属框架）被误识别为灯条。

**表现**：

* `Lightbar` 宽度增加；
* 角度识别不准；
* 长宽比（`length/width`）变小。

**对策**：

* 在 HSV / 灰度阈值前加亮度限制；
* 二值化后再做 **形态学腐蚀**（`cv::erode`）；
* 在匹配时检测 `length/width` 是否偏离正常范围。

---

### 8️⃣ **灯条模糊 / 运动拖影**

**原因**：

* 快速运动目标；
* 相机快门过慢；
* 夜间模式下曝光时间长。

**表现**：

* `Lightbar` 边缘模糊；
* 角度计算不稳定；
* `ratio` 和 `rectangular_error` 大幅波动。

**对策**：

* 降低曝光 / 增加快门速度；
* 时间滤波（`EMA` / `Kalman`）平滑几帧数据；
* 对角度采用加权平均平滑：

  ```cpp
  angle = 0.7 * prev_angle + 0.3 * new_angle;
  ```

---

### 9️⃣ **远距离目标（像素极少）**

**原因**：

* 目标太小（每个灯条仅 3–5 像素宽）；
* 光照不足、边缘不清晰。

**表现**：

* 灯条检测抖动；
* 长宽比波动；
* 匹配到的 `ratio` 误差大。

**对策**：

* 用形态学闭运算平滑轮廓；
* 调整最小面积阈值；
* 在 Armor 匹配时使用动态阈值（随距离变化）。

---

### 🔟 **背景中存在伪灯条**

**原因**：

* 背景灯、反光标志；
* 敌方机械臂等结构发光。

**表现**：

* 多余灯条导致错误匹配；
* ratio / side_ratio 正常但 `angle_diff` 不一致。

**对策**：

* 用装甲板亮度模式或形状识别过滤；
* 增加 “模式图案识别” (`pattern` CNN 分类)；
* 结合颜色通道（红蓝）判断灯条一致性。

---

## 📐 三、数学计算层面边界情况

### 11️⃣ **除零风险**

当某个灯条的宽度或长度为 0（错误矩形）时：

```cpp
ratio = width / max_lightbar_length;
```

会出现除以 0。

**对策**：

```cpp
ratio = (max_lightbar_length > 1e-6) ? width / max_lightbar_length : 0.0;
```

---

### 12️⃣ **角度跳变 / 不连续**

**原因**：

* `atan2` 返回角度在 `[-π, π]`；
* 小范围跨越 180° 时角度差突然从 179° 跳到 -179°。

**表现**：

* 瞬时误差极大；
* 角度图抖动。

**对策**：

* 使用连续角度平滑函数：

  ```cpp
  float delta = atan2(sin(a2 - a1), cos(a2 - a1));
  ```

  这样能得到平滑的“最短角度差”。

---

### 13️⃣ **矩形点顺序错误导致 PnP 出错**

**原因**：

* `points` 顺序错乱（不是标准顺时针/逆时针）；
* `solvePnP()` 得到错误姿态。

**对策**：

* 明确顺序：左上→右上→右下→左下；
* 可以使用 `cv::convexHull()` 检查一致性。

---

## 🧠 总结：可加进你代码的检测逻辑

| 项目                | 含义           | 典型阈值 | 异常处理方式   |
| ------------------- | -------------- | -------- | -------------- |
| `side_ratio`        | 左右灯条长度比 | < 2.0    | 否则丢弃       |
| `ratio`             | 灯条距/长度比  | 1.5–5.0  | 超出范围丢弃   |
| `angle_diff`        | 左右角度差     | < 10°    | 否则丢弃       |
| `rectangular_error` | 垂直偏差       | < 15°    | 否则降低置信度 |
| `Lightbar::ratio`   | 自身长宽比     | 2–20     | 否则丢弃       |

---

如果你想，我可以：

* ✅ 帮你把这些边界条件整合进 `Armor::isValid()` 函数（返回 true/false）；
* 或者 ✅ 画出一张图，标明这些典型异常的几何样子（例如“角度偏差”、“长度不对称”、“距离异常”）。

要我帮你哪一个？
